<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NFC位置批量检测器</title>
  <style>
    .container {
      margin: 20px;
    }

    #imageCanvas {
      border: 1px solid #ccc;
      margin-top: 20px;
      max-width: 500px;
    }

    .coordinates {
      margin-top: 10px;
      font-size: 14px;
      white-space: pre-wrap;
    }

    #results {
      margin-top: 20px;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 4px;
      font-family: monospace;
      white-space: pre;
      overflow-x: auto;
      position: relative;
    }

    .progress {
      margin-top: 10px;
      color: #666;
    }

    .button-group {
      margin-top: 10px;
      display: flex;
      gap: 10px;
    }

    button {
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background-color: #45a049;
    }

    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }

    .copy-success {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      display: none;
    }
  </style>
</head>


<body>
  <div class="container">
    <input type="file" id="folderInput" webkitdirectory directory multiple>
    <div class="progress">处理进度：<span id="progress">0/0</span></div>
    <div class="button-group">
      <button id="downloadBtn" style="display:none;">下载JSON结果</button>
      <button id="copyBtn" style="display:none;">复制结果</button>
    </div>
    <div id="results">暂无结果</div>
    <canvas id="imageCanvas"></canvas>
  </div>
  <div id="copySuccess" class="copy-success">复制成功！</div>

  <script>
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const folderInput = document.getElementById('folderInput');
    const resultsDiv = document.getElementById('results');
    const progressSpan = document.getElementById('progress');
    const downloadBtn = document.getElementById('downloadBtn');
    const copyBtn = document.getElementById('copyBtn');
    const copySuccess = document.getElementById('copySuccess');

    let allResults = [];
    let totalFiles = 0;
    let processedFiles = 0;

    // 处理文件夹上传
    folderInput.addEventListener('change', async function (e) {
      const files = Array.from(e.target.files).filter(file =>
        file.type.startsWith('image/')
      );

      totalFiles = files.length;
      processedFiles = 0;
      allResults = [];
      updateResults(allResults);
      updateProgress();

      for (const file of files) {
        await processFile(file);
      }

      console.log('所有文件处理完成');
    });

    // 下载结果
    downloadBtn.addEventListener('click', function () {
      const jsonString = JSON.stringify(allResults, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'nfc_locations.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // 更新进度显示
    function updateProgress() {
      progressSpan.textContent = `${processedFiles}/${totalFiles}`;
    }

    // 从文件路径构建模型名称
    function buildModelName(filePath) {
      const parts = filePath.split('/');
      // 移除文件名
      parts.pop();
      // 移除空字符串
      return parts.filter(part => part).join(' ');
    }

    // 处理单个文件
    async function processFile(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = function (event) {
          const img = new Image();
          img.onload = function () {
            console.log(`处理文件: ${file.name}`);
            const result = processImage(img);
            console.log(`处理结果:`, result);

            if (result) {
              // 从文件路径中提取品牌和型号信息
              const pathParts = file.webkitRelativePath.split('/').filter(part => part); // 过滤掉空字符串
              
              // 安全地获取品牌和型号
              let model = 'UNKNOWN';
              let brand = 'UNKNOWN';
              
              if (pathParts.length >= 2) {
                // 至少有文件名和一层目录
                model = pathParts[pathParts.length - 2]; // 倒数第二个是型号
                if (pathParts.length >= 3) {
                  brand = pathParts[pathParts.length - 3]; // 倒数第三个是品牌
                }
              }

              console.log('路径解析:', {
                fullPath: file.webkitRelativePath,
                pathParts,
                brand,
                model
              });

              // 创建新的结果对象
              const resultObject = {
                device: {
                  brand: brand.toUpperCase(),
                  model: model.toUpperCase(),
                  width: result.nfcLocation.deviceWidth,
                  height: result.nfcLocation.deviceHeight
                },
                nfcLocation: {
                  top: result.nfcLocation.top,
                  left: result.nfcLocation.left,
                  width: result.nfcLocation.width,
                  height: result.nfcLocation.height
                }
              };

              // 添加到结果数组
              allResults.push(resultObject);

              // 更新显示
              updateResults(allResults);
            } else {
              console.log(`文件 ${file.name} 未检测到有效区域`);
            }

            processedFiles++;
            updateProgress();
            resolve();
          }
          img.src = event.target.result;
        }
        reader.readAsDataURL(file);
      });
    }

    // 检测设备边界（去除空白区域）
    function detectDeviceBounds(imageData, width, height) {
      if (!imageData || !imageData.data || !width || !height) {
        console.error('无效的图像数据');
        return {
          x: 0,
          y: 0,
          width: width || 0,
          height: height || 0
        };
      }

      const data = imageData.data;
      let minX = width;
      let minY = height;
      let maxX = 0;
      let maxY = 0;
      const threshold = 180; // 颜色阈值

      // 用于记录每行和每列的非透明且非白色像素计数
      const rowCounts = new Array(height).fill(0);
      const colCounts = new Array(width).fill(0);

      // 第一遍扫描：统计每行每列的有效像素
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const index = (y * width + x) * 4;
          const r = data[index];
          const g = data[index + 1];
          const b = data[index + 2];
          const a = data[index + 3];

          // 检查像素是否为设备的一部分
          // 1. 不是完全透明的
          // 2. 是灰色的（RGB值相近）或者是深色的
          const isTransparent = a < 10;
          const isGray = Math.abs(r - g) < 30 && Math.abs(g - b) < 30 && Math.abs(r - b) < 30;
          const isDark = r < 50 && g < 50 && b < 50;
          
          // 如果是设备的一部分（非透明且是灰色或深色）
          if (!isTransparent && (isGray || isDark)) {
            rowCounts[y]++;
            colCounts[x]++;
          }
        }
      }

      // 设定最小连续像素阈值（比如图片宽度的3%）
      const minContinuous = Math.floor(width * 0.03);

      // 从上到下查找第一个有效行
      for (let y = 0; y < height; y++) {
        if (rowCounts[y] > minContinuous) {
          minY = y;
          break;
        }
      }

      // 从下到上查找最后一个有效行
      for (let y = height - 1; y >= 0; y--) {
        if (rowCounts[y] > minContinuous) {
          maxY = y;
          break;
        }
      }

      // 从左到右查找第一个有效列
      for (let x = 0; x < width; x++) {
        if (colCounts[x] > minContinuous) {
          minX = x;
          break;
        }
      }

      // 从右到左查找最后一个有效列
      for (let x = width - 1; x >= 0; x--) {
        if (colCounts[x] > minContinuous) {
          maxX = x;
          break;
        }
      }

      // 添加边界检查
      if (minX >= maxX || minY >= maxY) {
        console.log('未能正确检测到设备边界');
        return {
          x: 0,
          y: 0,
          width: width,
          height: height
        };
      }

      // 在canvas上标记检测到的边界（用于调试）
      ctx.strokeStyle = 'green';
      ctx.lineWidth = 1;
      ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);

      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }

    // 处理图片的函数
    function processImage(img) {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      // 检测设备边界
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const deviceBounds = detectDeviceBounds(imageData, canvas.width, canvas.height);
      
      console.log('设备边界:', deviceBounds);
      
      // 在原图上标记设备边界
      ctx.strokeStyle = 'green';
      ctx.lineWidth = 1;
      ctx.strokeRect(deviceBounds.x, deviceBounds.y, deviceBounds.width, deviceBounds.height);

      // 获取裁剪后的设备区域的图像数据
      const deviceImageData = ctx.getImageData(
          deviceBounds.x, 
          deviceBounds.y, 
          deviceBounds.width, 
          deviceBounds.height
      );

      // 使用检测到的设备尺寸和裁剪后的图像数据
      return detectRedRectangle(deviceImageData, deviceBounds.width, deviceBounds.height);
    }

    function detectRedRectangle(deviceImageData, deviceWidth, deviceHeight) {
      if (!deviceImageData || !deviceWidth || !deviceHeight) {
          console.error('无效的设备图像数据或尺寸');
          return null;
      }

      let result = detectColorRegion(deviceImageData, deviceWidth, deviceHeight, 
          (r, g, b) => {
              // 更精确的红色检测条件
              return r > 180 && // 降低红色阈值
                     g < 80 && // 提高绿色容差
                     b < 80 && // 提高蓝色容差
                     (r - g) > 100 && // 确保红色分量显著高于其他分量
                     (r - b) > 100;
          },
          '红色'
      );

      if (!result) {
          // 如果没有检测到红色区域，尝试检测黑色实线
          result = detectColorRegion(deviceImageData, deviceWidth, deviceHeight, 
              (r, g, b) => {
                  // 更严格的黑色检测条件
                  const brightness = (r + g + b) / 3;
                  return brightness < 50 && Math.abs(r - g) < 10 && Math.abs(g - b) < 10;
              },
              '黑色'
          );
      }

      return result;
    }

    function detectColorRegion(deviceImageData, deviceWidth, deviceHeight, colorCondition, colorName) {
      if (!deviceImageData || !deviceImageData.data || !deviceWidth || !deviceHeight) {
          console.error('无效的图像数据或设备尺寸');
          return null;
      }

      const data = deviceImageData.data;
      let minX = deviceWidth;
      let minY = deviceHeight;
      let maxX = 0;
      let maxY = 0;
      let foundColor = false;
      let colorPixelCount = 0;
      const totalPixels = deviceWidth * deviceHeight;

      // 遍历裁剪后的设备区域
      for (let y = 0; y < deviceHeight; y++) {
          for (let x = 0; x < deviceWidth; x++) {
              const index = (y * deviceWidth + x) * 4;
              const r = data[index];
              const g = data[index + 1];
              const b = data[index + 2];
              
              if (colorCondition(r, g, b)) {
                  colorPixelCount++;
                  foundColor = true;
                  minX = Math.min(minX, x);
                  minY = Math.min(minY, y);
                  maxX = Math.max(maxX, x);
                  maxY = Math.max(maxY, y);
              }
          }
      }

      // ... 其余验证逻辑保持不变 ...

      if (foundColor) {
          // 调整坐标确保在线内
          minX += 1;
          minY += 1;
          maxX -= 1;
          maxY -= 1;

          // 重新计算宽高
          const adjustedWidth = maxX - minX;
          const adjustedHeight = maxY - minY;

          // 返回相对于设备边界的坐标
          const result = {
              nfcLocation: {
                  top: minY,
                  left: minX,
                  width: adjustedWidth,
                  height: adjustedHeight,
                  deviceWidth: deviceWidth,
                  deviceHeight: deviceHeight
              }
          };

          return result;
      }

      return null;
    }

    // 修改显示结果的函数
    function updateResults(results) {
      const formattedJson = JSON.stringify(results, null, 2);
      resultsDiv.innerHTML = `<pre>${formattedJson}</pre>`;

      // 如果有结果，显示复制按钮
      if (results && results.length > 0) {
        copyBtn.style.display = 'block';
        downloadBtn.style.display = 'block';
      } else {
        copyBtn.style.display = 'none';
        downloadBtn.style.display = 'none';
      }
    }

    // 添加复制功能
    copyBtn.addEventListener('click', async function () {
      try {
        const formattedJson = JSON.stringify(allResults, null, 2);
        await navigator.clipboard.writeText(formattedJson);

        // 显示复制成功提示
        copySuccess.style.display = 'block';
        setTimeout(() => {
          copySuccess.style.display = 'none';
        }, 2000);
      } catch (err) {
        console.error('复制失败:', err);
        alert('复制失败，请手动复制');
      }
    });
  </script>
</body>

</html>