<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NFC位置批量检测器</title>
  <style>
    .container {
      margin: 20px;
    }

    #imageCanvas {
      border: 1px solid #ccc;
      margin-top: 20px;
      max-width: 500px;
    }

    .coordinates {
      margin-top: 10px;
      font-size: 14px;
      white-space: pre-wrap;
    }

    #results {
      margin-top: 20px;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 4px;
      font-family: monospace;
      white-space: pre;
      overflow-x: auto;
      position: relative;
    }

    .progress {
      margin-top: 10px;
      color: #666;
    }

    .button-group {
      margin-top: 10px;
      display: flex;
      gap: 10px;
    }

    button {
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background-color: #45a049;
    }

    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }

    .copy-success {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      display: none;
    }
  </style>
</head>


<body>
  <div class="container">
    <input type="file" id="folderInput" webkitdirectory directory multiple>
    <div class="progress">处理进度：<span id="progress">0/0</span></div>
    <div class="button-group">
      <button id="downloadBtn" style="display:none;">下载JSON结果</button>
      <button id="copyBtn" style="display:none;">复制结果</button>
    </div>
    <div id="results">暂无结果</div>
    <canvas id="imageCanvas"></canvas>
  </div>
  <div id="copySuccess" class="copy-success">复制成功！</div>

  <script>
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');
    const folderInput = document.getElementById('folderInput');
    const resultsDiv = document.getElementById('results');
    const progressSpan = document.getElementById('progress');
    const downloadBtn = document.getElementById('downloadBtn');
    const copyBtn = document.getElementById('copyBtn');
    const copySuccess = document.getElementById('copySuccess');

    let allResults = [];
    let totalFiles = 0;
    let processedFiles = 0;

    // 处理文件夹上传
    folderInput.addEventListener('change', async function (e) {
      const files = Array.from(e.target.files).filter(file =>
        file.type.startsWith('image/')
      );

      totalFiles = files.length;
      processedFiles = 0;
      allResults = [];
      updateResults(allResults);
      updateProgress();

      for (const file of files) {
        await processFile(file);
      }

      console.log('所有文件处理完成');
    });

    // 下载结果
    downloadBtn.addEventListener('click', function () {
      const jsonString = JSON.stringify(allResults, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'nfc_locations.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // 更新进度显示
    function updateProgress() {
      progressSpan.textContent = `${processedFiles}/${totalFiles}`;
    }

    // 从文件路径构建模型名称
    function buildModelName(filePath) {
      const parts = filePath.split('/');
      // 移除文件名
      parts.pop();
      // 移除空字符串
      return parts.filter(part => part).join(' ');
    }

    // 处理单个文件
    async function processFile(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = function (event) {
          const img = new Image();
          img.onload = function () {
            console.log(`处理文件: ${file.name}`);
            const result = processImage(img);
            console.log(`处理结果:`, result);

            if (result) {
              // 从文件路径中提取品牌和型号信息
              const pathParts = file.webkitRelativePath.split('/').filter(part => part); // 过滤掉空字符串
              
              // 从后往前取，倒数第二个是型号，倒数第三个是品牌
              const fileName = pathParts[pathParts.length - 1]; // 文件名
              const model = pathParts.length >= 2 ? pathParts[pathParts.length - 2] : 'UNKNOWN'; // 取倒数第二个作为型号
              const brand = pathParts.length >= 3 ? pathParts[pathParts.length - 3] : 'UNKNOWN'; // 取倒数第三个作为品牌
              
              console.log('路径解析:', {
                  fullPath: file.webkitRelativePath,
                  pathParts,
                  brand,
                  model
              });

              // 创建新的结果对象，使用 toUpperCase() 转换为大写
              const resultObject = {
                  device: {
                      brand: brand.toUpperCase(),
                      model: model.toUpperCase(),
                      width: result.nfcLocation.deviceWidth,
                      height: result.nfcLocation.deviceHeight
                  },
                  nfcLocation: {
                      top: result.nfcLocation.top,
                      left: result.nfcLocation.left,
                      width: result.nfcLocation.width,
                      height: result.nfcLocation.height
                  }
              };

              // 添加到结果数组
              allResults.push(resultObject);

              // 在页面上显示实时结果
              updateResults(allResults);
            } else {
              console.log(`文件 ${file.name} 未检测到有效区域`);
            }

            processedFiles++;
            updateProgress();
            resolve();
          }
          img.src = event.target.result;
        }
        reader.readAsDataURL(file);
      });
    }

    // 检测设备边界（去除空白区域）
    function detectDeviceBounds(imageData, width, height) {
      const data = imageData.data;
      let minX = width;
      let minY = height;
      let maxX = 0;
      let maxY = 0;
      const threshold = 180;

      // 用于记录每行和每列的非白色像素计数
      const rowCounts = new Array(height).fill(0);
      const colCounts = new Array(width).fill(0);

      // 第一遍扫描：统计每行每列的非白色像素
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const index = (y * width + x) * 4;
          const r = data[index];
          const g = data[index + 1];
          const b = data[index + 2];

          // 使用更严格的判断条件
          if (Math.abs(r - g) < 10 && Math.abs(g - b) < 10 && r < threshold) {
            rowCounts[y]++;
            colCounts[x]++;
          }
        }
      }

      // 设定最小连续像素阈值（比如图片宽度的10%）
      const minContinuous = Math.floor(width * 0.1);

      // 从两端向中间查找连续的有效行
      for (let y = 0; y < height; y++) {
        if (rowCounts[y] > minContinuous) {
          minY = y;
          break;
        }
      }
      for (let y = height - 1; y >= 0; y--) {
        if (rowCounts[y] > minContinuous) {
          maxY = y;
          break;
        }
      }

      // 从两端向中间查找连续的有效列
      for (let x = 0; x < width; x++) {
        if (colCounts[x] > minContinuous) {
          minX = x;
          break;
        }
      }
      for (let x = width - 1; x >= 0; x--) {
        if (colCounts[x] > minContinuous) {
          maxX = x;
          break;
        }
      }

      // 添加边界检查
      if (minX >= maxX || minY >= maxY) {
        console.log('未能正确检测到设备边界');
        return {
          x: 0,
          y: 0,
          width: width,
          height: height
        };
      }

      // 添加一些边距
      const padding = 2;
      minX = Math.max(0, minX - padding);
      minY = Math.max(0, minY - padding);
      maxX = Math.min(width - 1, maxX + padding);
      maxY = Math.min(height - 1, maxY + padding);

      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }

    // 处理图片的函数
    function processImage(img) {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      // 检测设备边界
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const deviceBounds = detectDeviceBounds(imageData, canvas.width, canvas.height);

      console.log('设备边界:', deviceBounds);

      // 在原图上标记设备边界
      ctx.strokeStyle = 'green';
      ctx.lineWidth = 1;
      ctx.strokeRect(deviceBounds.x, deviceBounds.y, deviceBounds.width, deviceBounds.height);

      // 使用检测到的设备尺寸，并返回检测结果
      return detectRedRectangle(deviceBounds.width, deviceBounds.height);
    }

    function detectRedRectangle(deviceWidth, deviceHeight) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      let result = detectColorRegion(data, deviceWidth, deviceHeight,
        (r, g, b) => {
          // 更精确的红色检测条件
          return r > 180 && // 降低红色阈值
            g < 80 && // 提高绿色容差
            b < 80 && // 提高蓝色容差
            (r - g) > 100 && // 确保红色分量显著高于其他分量
            (r - b) > 100;
        },
        '红色'
      );

      if (!result) {
        // 如果没有检测到红色区域，尝试检测黑色实线
        result = detectColorRegion(data, deviceWidth, deviceHeight,
          (r, g, b) => {
            // 更严格的黑色检测条件
            const brightness = (r + g + b) / 3;
            return brightness < 50 && Math.abs(r - g) < 10 && Math.abs(g - b) < 10;
          },
          '黑色'
        );
      }

      return result;
    }

    function detectColorRegion(imageData, deviceWidth, deviceHeight, colorCondition, colorName) {
      let minX = canvas.width;
      let minY = canvas.height;
      let maxX = 0;
      let maxY = 0;
      let foundColor = false;
      let colorPixelCount = 0;
      const totalPixels = canvas.width * canvas.height;

      // 用于存储连续的黑色像素计数
      let continuousPixels = new Array(canvas.width).fill(0);

      console.log(`开始检测${colorName}区域`);
      console.log(`图片尺寸: ${deviceWidth} x ${deviceHeight}`);

      for (let y = 0; y < canvas.height; y++) {
        let lineColorCount = 0; // 每行的颜色像素计数

        for (let x = 0; x < canvas.width; x++) {
          const index = (y * canvas.width + x) * 4;
          const r = imageData[index];
          const g = imageData[index + 1];
          const b = imageData[index + 2];

          if (colorCondition(r, g, b)) {
            lineColorCount++;
            colorPixelCount++;

            // 记录连续像素
            continuousPixels[x]++;

            // 只有当周围也有相同颜色时才认为是有效区域
            if (x > 0 && x < canvas.width - 1) {
              const prevIndex = (y * canvas.width + (x - 1)) * 4;
              const nextIndex = (y * canvas.width + (x + 1)) * 4;
              const isPrevSameColor = colorCondition(
                imageData[prevIndex],
                imageData[prevIndex + 1],
                imageData[prevIndex + 2]
              );
              const isNextSameColor = colorCondition(
                imageData[nextIndex],
                imageData[nextIndex + 1],
                imageData[nextIndex + 2]
              );

              if (isPrevSameColor || isNextSameColor) {
                foundColor = true;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
              }
            }
          } else {
            continuousPixels[x] = 0;
          }
        }
      }

      console.log(`找到的${colorName}像素总数: ${colorPixelCount}`);
      console.log(`区域范围: (${minX}, ${minY}) - (${maxX}, ${maxY})`);

      if (foundColor) {
        const width = maxX - minX + 1;
        const height = maxY - minY + 1;

        // 针对不同颜色使用不同的判断标准
        if (colorName === '红色') {
          // 红色区域的判断条件放宽
          if (width > deviceWidth * 0.8 && height > deviceHeight * 0.8) {
            console.log(`${colorName}区域过大: ${width} x ${height}`);
            return null;
          }

          // 红色区域太小也不行
          if (width < 20 || height < 20) {
            console.log(`${colorName}区域过小: ${width} x ${height}`);
            return null;
          }
        } else {
          // 黑色区域的判断保持原样
          if (width >= deviceWidth * 0.5 || height >= deviceHeight * 0.5) {
            console.log(`${colorName}区域过大: ${width} x ${height}`);
            return null;
          }
        }

        // 检查红色区域的占比
        const colorPixelRatio = colorPixelCount / totalPixels;
        if (colorName === '红色') {
          // 放宽红色区域的占比限制
          if (colorPixelRatio > 0.7) {
            console.log(`图片中${colorName}区域占比过大，请检查图片`);
            return null;
          }
        } else {
          // 黑色区域的占比限制保持不变
          if (colorPixelRatio > 0.5) {
            console.log(`图片中${colorName}区域占比过大，请检查图片`);
            return null;
          }
        }

        // 检查是否形成了连续的线条
        let hasValidLine = false;
        for (let x = 0; x < canvas.width; x++) {
          if (continuousPixels[x] > height * 0.5) {
            hasValidLine = true;
            break;
          }
        }

        if (!hasValidLine && colorName === '黑色') {
          console.log('未检测到有效的连续线条');
          return null;
        }

        // 调整坐标确保在线内
        minX += 1;
        minY += 1;
        maxX -= 1;
        maxY -= 1;

        // 重新计算宽高
        const adjustedWidth = maxX - minX;
        const adjustedHeight = maxY - minY;

        // 在canvas上标记检测到的区域
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 2;
        ctx.strokeRect(minX - 1, minY - 1, adjustedWidth + 2, adjustedHeight + 2);

        // 修改返回的结果格式
        const result = {
          nfcLocation: {
            top: minY,
            left: minX,
            width: adjustedWidth,
            height: adjustedHeight,
            deviceWidth: Math.round(deviceWidth),
            deviceHeight: Math.round(deviceHeight)
          }
        };

        return result;
      }

      return null;
    }

    // 修改显示结果的函数
    function updateResults(results) {
      const formattedJson = JSON.stringify(results, null, 2);
      resultsDiv.innerHTML = `<pre>${formattedJson}</pre>`;
      
      // 如果有结果，显示复制按钮
      if (results && results.length > 0) {
        copyBtn.style.display = 'block';
        downloadBtn.style.display = 'block';
      } else {
        copyBtn.style.display = 'none';
        downloadBtn.style.display = 'none';
      }
    }

    // 添加复制功能
    copyBtn.addEventListener('click', async function() {
      try {
        const formattedJson = JSON.stringify(allResults, null, 2);
        await navigator.clipboard.writeText(formattedJson);
        
        // 显示复制成功提示
        copySuccess.style.display = 'block';
        setTimeout(() => {
          copySuccess.style.display = 'none';
        }, 2000);
      } catch (err) {
        console.error('复制失败:', err);
        alert('复制失败，请手动复制');
      }
    });
  </script>
</body>

</html>